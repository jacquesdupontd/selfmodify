<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Emergent Life Engine</title>
    <style>
        * { margin: 0; padding: 0; overflow: hidden; }
        body { background: #000; font-family: monospace; }
        canvas { display: block; position: absolute; }
        #base { z-index: 1; }
        #fx { z-index: 2; }
        #info {
            position: fixed; top: 10px; left: 10px; color: #0f0; font-size: 9px; z-index: 999;
            background: rgba(0,0,0,0.7); padding: 6px; border-radius: 3px;
        }
        #audioBtn {
            position: fixed; top: 10px; right: 10px; z-index: 1000; padding: 8px 15px;
            background: rgba(0,255,0,0.2); border: 1px solid #0f0; color: #0f0;
            cursor: pointer; border-radius: 4px; font-family: monospace; font-size: 10px;
        }
        #help {
            position: fixed; bottom: 10px; right: 10px; z-index: 999;
            color: #0f0; font-size: 8px; background: rgba(0,0,0,0.8);
            padding: 5px 8px; border-radius: 3px; opacity: 0.6;
        }
    </style>
</head>
<body>
    <canvas id="base"></canvas>
    <canvas id="fx"></canvas>
    <div id="info">
        <div>FPS: <span id="fps">60</span> | MODE: <span id="mode">INIT</span></div>
        <div>AUDIO: <span id="audio">OFF</span> | AGENTS: <span id="count">0</span></div>
        <div style="font-size: 8px">B:<span id="bass">0</span> M:<span id="mid">0</span> H:<span id="high">0</span> P:<span id="pitch">-</span></div>
        <div style="font-size: 8px; color: #0ff">BPM:<span id="bpm">-</span> üéØ:<span id="phase">-</span> ‚ö°:<span id="latency">35</span>ms</div>
        <div style="font-size: 8px; color: #f0f">üß¨:<span id="colormode">MULTI</span> üñºÔ∏è:<span id="imagestate">-</span></div>
    </div>
    <button id="audioBtn">START AUDIO ‚ö°</button>
    <div id="help">‚¨Ü‚¨á Sync | R Reset | I Image | M Mutate | B&W DENSE MODE ‚ö°</div>

    <script>
        const baseCanvas = document.getElementById('base');
        const fxCanvas = document.getElementById('fx');
        const ctx = baseCanvas.getContext('2d', { alpha: false, desynchronized: true });
        const fxCtx = fxCanvas.getContext('2d', { alpha: true });

        let W, H, CX, CY;
        function resize() {
            W = baseCanvas.width = fxCanvas.width = window.innerWidth;
            H = baseCanvas.height = fxCanvas.height = window.innerHeight;
            CX = W / 2; CY = H / 2;
        }
        resize();
        window.addEventListener('resize', resize);

        // UNIVERSE STATE
        const U = {
            t: 0, fps: 60, lastTime: performance.now(),
            hue: 0, mode: 'calm', modeTimer: 0, intensity: 0.5,

            // Audio
            audioActive: false, audioContext: null, analyser: null,
            dataArray: null, bufferLength: 0,
            bass: 0, mid: 0, high: 0, energy: 0, beat: 0,
            spectralCentroid: 0, spectralFlux: 0, onset: 0,
            pitch: 0, pitchConfidence: 0,
            energyHistory: [], lastDataArray: null,

            // üéØ DUAL-CLOCK SYNC ENGINE
            audioTime: 0,              // Precise audio clock (seconds)
            visualTime: 0,             // Visual render time (seconds)
            latencyCompensation: 0.035, // 35ms lookahead (tunable 20-50ms)
            syncOffset: 0,             // Dynamic calibration offset

            // üéµ BPM DETECTION & PHASE-LOCKED LOOP
            bpm: 0,                    // Detected tempo
            beatPhase: 0,              // 0-1 position in beat cycle
            beatInterval: 0,           // Seconds between beats
            lastBeatTime: 0,           // Audio time of last beat
            nextBeatTime: 0,           // Predicted next beat
            beatHistory: [],           // Timestamps for BPM analysis
            beatConfidence: 0,         // How sure we are of tempo
            scheduledEvents: [],       // Future events queue

            // Effects
            chromatic: 0, bloom: 0, distortion: 0,

            // Attractors & zones
            attractors: [],
            zones: [],

            // üß¨ ORGANIC COLOR GENOME
            colorGenome: {
                hueGene: Math.random() * 360,          // Base hue drift
                hueDrift: (Math.random() - 0.5) * 2,   // Drift speed
                saturationGene: 0.9,                   // 0-1 saturation (HIGH for vibrant!)
                saturationDrift: 0,
                lightnessGene: 0.5,                     // 0-1 brightness
                lightnessDrift: 0,
                harmonyMode: 'multi',                   // mono/duo/triad/multi/bw
                chromaticStress: 0,                     // 0=BW, 1=saturated
                mutationRate: 0.001,                    // Probability of sudden change
                noiseOffset: Math.random() * 1000,      // Perlin noise seed
                evolution: 0                             // Evolution time counter
            },

            // üåå IMAGE REALITY FEED
            imageSystem: {
                currentImage: null,
                nextImage: null,
                imageCanvas: null,
                imageCtx: null,
                edgeMap: [],                            // Edge detection results
                colorClusters: [],                      // Dominant colors
                brightnessMap: [],                      // Pixel brightness
                imageAttractors: [],                    // Attractors from image
                morphProgress: 0,                       // Particle shape formation progress
                lastFetchTime: 0,
                lastBeatCount: 0,                       // Track beats for rhythm changes
                beatsPerImage: 4,                       // Start: change every 4 beats
                beatCounter: 0,                         // Count beats since last change
                imageReady: false,
                imageWidth: 0,
                imageHeight: 0
            },

            updateEntropy() {
                const now = Date.now();
                this.entropy = (now % 999999 + performance.now() * 17 + this.t * 137.508) % 999999;
            },

            updateMode() {
                this.modeTimer++;

                // üéµ BEAT-LOCKED MODE CHANGES: Only switch on downbeat when music is playing
                const canChange = this.beatConfidence > 0.5 ?
                    (this.beatPhase < 0.1 && Math.random() < 0.3) : // On beat
                    (Math.random() < 0.01 || this.modeTimer > 120 + Math.random() * 100); // Random

                if (canChange) {
                    this.modeTimer = 0;
                    const modes = ['calm', 'explosion', 'implosion', 'tornado', 'chaos',
                                   'waves', 'vortex', 'quantum', 'magnetic', 'mitosis', 'plasma'];
                    this.mode = modes[Math.floor(Math.random() * modes.length)];
                }

                if (Math.random() < 0.015) this.intensity = Math.random() * 2.5;
            },

            // üéØ DUAL-CLOCK: Update audio time with lookahead compensation
            updateAudioClock() {
                if (!this.audioActive || !this.audioContext) {
                    this.audioTime = this.visualTime;
                    return;
                }

                // Audio clock is THE truth - visual follows with compensation
                this.audioTime = this.audioContext.currentTime;

                // Visual time runs ahead to compensate for processing lag
                this.visualTime = this.audioTime + this.latencyCompensation + this.syncOffset;
            },

            // üéµ BPM DETECTION: Analyze beat intervals
            detectBPM() {
                if (this.beatHistory.length < 4) return;

                // Calculate intervals between recent beats
                const intervals = [];
                for (let i = 1; i < this.beatHistory.length; i++) {
                    intervals.push(this.beatHistory[i] - this.beatHistory[i - 1]);
                }

                // Filter outliers (remove intervals outside 300-2000ms / 30-200 BPM)
                const validIntervals = intervals.filter(i => i > 0.3 && i < 2.0);
                if (validIntervals.length < 2) return;

                // Calculate median interval (robust against false beats)
                const sorted = validIntervals.slice().sort((a, b) => a - b);
                const median = sorted[Math.floor(sorted.length / 2)];

                // Smooth BPM changes
                const newBPM = 60 / median;
                this.bpm = this.bpm === 0 ? newBPM : this.bpm * 0.85 + newBPM * 0.15;
                this.beatInterval = 60 / this.bpm;

                // Calculate confidence based on consistency
                const variance = validIntervals.reduce((sum, i) => sum + Math.abs(i - median), 0) / validIntervals.length;
                this.beatConfidence = Math.max(0, 1 - variance * 5);
            },

            // üéµ PHASE-LOCKED LOOP: Predict next beat
            updateBeatPhase() {
                if (this.beatInterval === 0 || this.lastBeatTime === 0) return;

                // Calculate phase (0-1) within current beat cycle
                const timeSinceLastBeat = this.audioTime - this.lastBeatTime;
                this.beatPhase = (timeSinceLastBeat / this.beatInterval) % 1;

                // Predict next beat time
                this.nextBeatTime = this.lastBeatTime + this.beatInterval;

                // If we're past predicted beat, advance to next cycle
                if (this.audioTime > this.nextBeatTime) {
                    this.lastBeatTime = this.nextBeatTime;
                    this.nextBeatTime += this.beatInterval;
                }
            },

            // üöÄ SCHEDULE EVENT: Queue visual event at precise audio time
            scheduleEvent(eventTime, callback, data = {}) {
                this.scheduledEvents.push({ time: eventTime, callback, data });
                // Sort by time (earliest first)
                this.scheduledEvents.sort((a, b) => a.time - b.time);
            },

            // ‚ö° PROCESS SCHEDULED EVENTS: Trigger when visual time catches up
            processScheduledEvents() {
                while (this.scheduledEvents.length > 0) {
                    const event = this.scheduledEvents[0];

                    // If visual time has reached event time, trigger it
                    if (this.visualTime >= event.time) {
                        event.callback(event.data);
                        this.scheduledEvents.shift();
                    } else {
                        break; // Future events wait
                    }
                }
            },

            // üß¨ EVOLVE COLOR GENOME: Organic color consciousness
            evolveColorGenome() {
                const g = this.colorGenome;
                g.evolution += 0.016;

                // Multi-scale Perlin drift (slow organic evolution)
                const slowNoise = perlin((g.evolution + g.noiseOffset) * 0.02, 3);
                const mediumNoise = perlin((g.evolution + g.noiseOffset) * 0.1, 2);
                const fastNoise = perlin((g.evolution + g.noiseOffset) * 0.5, 2);

                // Hue drift (continuous evolution)
                g.hueDrift += slowNoise * 0.5;
                g.hueGene = (g.hueGene + g.hueDrift + mediumNoise * 2) % 360;

                // Saturation breathing (KEEP IT HIGH for vibrant colors!)
                g.saturationDrift += mediumNoise * 0.01;
                g.saturationGene = Math.max(0.6, Math.min(1, g.saturationGene + g.saturationDrift * 0.1)); // Min 60%!

                // Lightness oscillation
                g.lightnessDrift += fastNoise * 0.008;
                g.lightnessGene = Math.max(0.2, Math.min(0.8, g.lightnessGene + g.lightnessDrift * 0.05));

                // Chromatic stress evolution (BW ‚Üî Color tension)
                g.chromaticStress += mediumNoise * 0.02;
                g.chromaticStress = Math.max(0, Math.min(1, g.chromaticStress));

                // üî• MUTATIONS: Sudden phase flips
                if (Math.random() < g.mutationRate || (this.beat > 0.3 && Math.random() < 0.05)) {
                    const mutations = [
                        () => { g.harmonyMode = ['mono', 'duo', 'triad', 'multi', 'bw'][Math.floor(Math.random() * 5)]; },
                        () => { g.chromaticStress = Math.random(); },
                        () => { g.saturationGene = Math.random(); },
                        () => { g.hueGene = Math.random() * 360; },
                        () => { g.lightnessGene = 0.3 + Math.random() * 0.4; }
                    ];
                    mutations[Math.floor(Math.random() * mutations.length)]();
                }

                // Audio-reactive DNA damage
                if (this.onset > 0.3) {
                    g.chromaticStress = Math.min(1, g.chromaticStress + this.onset * 0.5);
                }
                if (this.bass > 0.7) {
                    g.lightnessGene = Math.max(0.2, g.lightnessGene - this.bass * 0.1);
                }
            },

            // üé® GET COLOR FROM GENOME: Generate colors based on evolved DNA
            getColorFromGenome(variation = 0, energyMod = 1) {
                const g = this.colorGenome;
                let h, s, l;

                switch(g.harmonyMode) {
                    case 'mono':
                        h = g.hueGene;
                        s = g.saturationGene * 100;
                        l = (g.lightnessGene + variation * 0.1) * 100;
                        break;

                    case 'duo':
                        h = variation > 0 ? g.hueGene : (g.hueGene + 180) % 360;
                        s = g.saturationGene * 100;
                        l = g.lightnessGene * 100;
                        break;

                    case 'triad':
                        const triadShift = Math.floor(variation * 3) * 120;
                        h = (g.hueGene + triadShift) % 360;
                        s = g.saturationGene * 100;
                        l = g.lightnessGene * 100;
                        break;

                    case 'bw':
                        h = 0;
                        s = 0;
                        l = (g.lightnessGene + variation * 0.2) * 100;
                        break;

                    case 'multi':
                    default:
                        h = (g.hueGene + variation * 50) % 360;
                        s = (g.saturationGene * 0.7 + 0.3) * 100;
                        l = g.lightnessGene * 100;
                        break;
                }

                // Apply chromatic stress (desaturate when stress low)
                s = s * g.chromaticStress;

                // Energy modulation
                l = Math.max(20, Math.min(80, l + energyMod * 15));

                return { h, s, l };
            },

            // üåå INITIALIZE IMAGE SYSTEM
            initImageSystem() {
                const img = this.imageSystem;
                img.imageCanvas = document.createElement('canvas');
                img.imageCtx = img.imageCanvas.getContext('2d', { willReadFrequently: true });
                img.imageCanvas.width = 320;  // Higher res for detail
                img.imageCanvas.height = 240;
                img.imageWidth = 320;
                img.imageHeight = 240;
            },

            // üñºÔ∏è FETCH RANDOM IMAGE
            async fetchRandomImage() {
                const img = this.imageSystem;

                try {
                    // üéØ B&W HIGH-CONTRAST IMAGES for clear shape recognition
                    const subjects = ['animal', 'cat', 'dog', 'bird', 'mountain', 'car', 'building', 'tree', 'person', 'silhouette'];
                    const subject = subjects[Math.floor(Math.random() * subjects.length)];

                    const sources = [
                        `https://source.unsplash.com/320x240/?${subject},blackandwhite&sig=${Math.random()}`,
                        `https://picsum.photos/320/240?grayscale&random=${Math.random()}`,
                    ];

                    // Try Picsum only (better CORS support for local files)
                    const url = `https://picsum.photos/320/240?grayscale&random=${Math.random()}`;

                    const image = new Image();
                    image.crossOrigin = 'anonymous'; // Required for http:// (works now that we're not on file://)

                    image.onload = () => {
                        img.currentImage = image;
                        this.processImage();
                        img.lastFetchTime = performance.now();
                    };

                    image.onerror = () => {
                        console.log('‚ö†Ô∏è Image load failed - CORS issue. Use local server!');
                    };

                    image.src = url;
                } catch (error) {
                    console.log('Image fetch skipped:', error);
                }
            },

            // üî¨ PROCESS IMAGE: Extract features
            processImage() {
                const img = this.imageSystem;
                if (!img.currentImage) return;

                // Draw image to processing canvas
                img.imageCtx.drawImage(img.currentImage, 0, 0, img.imageWidth, img.imageHeight);
                const imageData = img.imageCtx.getImageData(0, 0, img.imageWidth, img.imageHeight);
                const pixels = imageData.data;

                // Clear previous data
                img.edgeMap = [];
                img.colorClusters = [];
                img.brightnessMap = [];
                img.imageAttractors = [];

                // üéØ DENSE B&W SAMPLING - Every dark pixel becomes an attractor!
                const darkPixels = [];

                // First pass: Find ALL dark pixels (B&W threshold)
                for (let y = 0; y < img.imageHeight; y++) {
                    for (let x = 0; x < img.imageWidth; x++) {
                        const idx = (y * img.imageWidth + x) * 4;
                        const brightness = (pixels[idx] + pixels[idx + 1] + pixels[idx + 2]) / 3;

                        // B&W threshold: dark = shape
                        if (brightness < 110) {
                            darkPixels.push({
                                x: x,
                                y: y,
                                brightness: brightness
                            });
                        }
                    }
                }

                // Second pass: Sample densely from dark pixels (every 5th pixel for performance)
                const sampleRate = Math.max(1, Math.floor(darkPixels.length / 1200)); // Target ~1200 attractors

                for (let i = 0; i < darkPixels.length; i += sampleRate) {
                    const p = darkPixels[i];
                    const screenX = (p.x / img.imageWidth) * W;
                    const screenY = (p.y / img.imageHeight) * H;

                    img.imageAttractors.push({
                        x: screenX,
                        y: screenY,
                        strength: (110 - p.brightness) / 110,
                        radius: 60, // LARGER radius so particles feel the pull (was 35)
                        color: { r: 255, g: 255, b: 255 } // B&W
                    });
                }

                console.log(`üéØ B&W DENSE: ${img.imageAttractors.length} shape points from ${darkPixels.length} dark pixels`);

                // B&W images - color genome keeps evolving organically
                // (No color injection needed for grayscale)

                // üöÄ TELEPORT PARTICLES TO IMAGE LOCATIONS (instant shape formation!)
                if (img.imageAttractors.length > 0 && agents.length > 0) {
                    // Redistribute 90% of particles to attractor positions (was 80%)
                    const particlesToMove = Math.floor(agents.length * 0.9);

                    for (let i = 0; i < particlesToMove; i++) {
                        const agent = agents[i];
                        // Pick random attractor
                        const attractor = img.imageAttractors[Math.floor(Math.random() * img.imageAttractors.length)];

                        // Teleport particle CLOSE to attractor (tighter scatter for precision)
                        agent.x = attractor.x + (Math.random() - 0.5) * 40; // Was 80, now 40
                        agent.y = attractor.y + (Math.random() - 0.5) * 40;

                        // Reset velocity
                        agent.vx = (Math.random() - 0.5) * 1;
                        agent.vy = (Math.random() - 0.5) * 1;

                        // üåà RANDOMIZE COLOR per particle!
                        agent.colorOffset = Math.random() * 360;
                    }

                    console.log(`‚ú® Teleported ${particlesToMove} particles to shape positions!`);
                }

                img.imageReady = true;
                img.morphProgress = 0; // Start forming the new shape
            },

            // üîç SOBEL EDGE DETECTION
            sobelEdgeDetection(pixels, width, height) {
                const edges = new Uint8Array(width * height);

                // Sobel kernels
                const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
                const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];

                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        let gx = 0, gy = 0;

                        // Apply kernels
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const idx = ((y + ky) * width + (x + kx)) * 4;
                                const gray = (pixels[idx] + pixels[idx + 1] + pixels[idx + 2]) / 3;
                                const kernelIdx = (ky + 1) * 3 + (kx + 1);

                                gx += gray * sobelX[kernelIdx];
                                gy += gray * sobelY[kernelIdx];
                            }
                        }

                        const magnitude = Math.sqrt(gx * gx + gy * gy);
                        edges[y * width + x] = Math.min(255, magnitude);
                    }
                }

                return edges;
            },

            // üé® EXTRACT DOMINANT COLORS (simplified K-means)
            extractDominantColors(pixels, k = 5) {
                const colors = [];
                const sampleSize = 1000;

                // Sample random pixels
                for (let i = 0; i < sampleSize; i++) {
                    const idx = Math.floor(Math.random() * (pixels.length / 4)) * 4;
                    colors.push({
                        r: pixels[idx],
                        g: pixels[idx + 1],
                        b: pixels[idx + 2]
                    });
                }

                // Simple clustering (just take spread samples for now)
                const clusters = [];
                for (let i = 0; i < k; i++) {
                    const sample = colors[Math.floor((i / k) * colors.length)];
                    clusters.push(sample);
                }

                return clusters;
            },

            // üåä UPDATE IMAGE SYSTEM (20 SECOND HOLDS!)
            updateImageSystem() {
                const img = this.imageSystem;

                // ‚è∞ HOLD IMAGE FOR 20 SECONDS (let shape form perfectly!)
                const timeSinceLastFetch = performance.now() - img.lastFetchTime;
                if (timeSinceLastFetch > 20000 || img.lastFetchTime === 0) { // 20 seconds!
                    this.fetchRandomImage();
                }

                // Fast fade in
                if (img.imageReady && img.morphProgress < 1) {
                    img.morphProgress = Math.min(1, img.morphProgress + 0.015); // Fast lock
                }
            },

            updateAttractors() {
                // Spawn attractors
                const spawnRate = this.audioActive ? 0.03 + this.beat * 0.1 : 0.02;
                if (Math.random() < spawnRate && this.attractors.length < 8) {
                    const type = Math.random() < 0.3 ? 'strange' : 'normal';
                    this.attractors.push({
                        x: CX + (Math.random() - 0.5) * W * 0.8,
                        y: CY + (Math.random() - 0.5) * H * 0.8,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        strength: (Math.random() - 0.5) * 3,
                        life: 100 + Math.random() * 300,
                        radius: 80 + Math.random() * 150,
                        type: type,
                        phase: Math.random() * Math.PI * 2
                    });
                }

                this.attractors = this.attractors.filter(a => {
                    a.life--;
                    a.x += a.vx + (Math.random() - 0.5) * (1 + this.high * 3);
                    a.y += a.vy + (Math.random() - 0.5) * (1 + this.high * 3);

                    if (a.type === 'strange') {
                        a.phase += 0.05;
                        a.x += Math.sin(a.phase) * 2;
                        a.y += Math.cos(a.phase) * 2;
                    }

                    return a.life > 0;
                });

                // Energy zones
                if (Math.random() < 0.01 && this.zones.length < 3) {
                    this.zones.push({
                        x: Math.random() * W,
                        y: Math.random() * H,
                        radius: 100 + Math.random() * 200,
                        strength: (Math.random() - 0.5) * 2,
                        life: 200,
                        hot: Math.random() < 0.5
                    });
                }

                this.zones = this.zones.filter(z => {
                    z.life--;
                    z.radius += (Math.random() - 0.5) * 5;
                    return z.life > 0;
                });
            },

            analyzeAudio() {
                if (!this.audioActive || !this.analyser) return;

                this.analyser.getByteFrequencyData(this.dataArray);

                const nyquist = this.audioContext.sampleRate / 2;
                const binWidth = nyquist / this.bufferLength;

                // Frequency bands
                let bassSum = 0, midSum = 0, highSum = 0;
                let bassCount = 0, midCount = 0, highCount = 0;

                for (let i = 0; i < this.bufferLength; i++) {
                    const freq = i * binWidth;
                    if (freq < 250) { bassSum += this.dataArray[i]; bassCount++; }
                    else if (freq < 2000) { midSum += this.dataArray[i]; midCount++; }
                    else { highSum += this.dataArray[i]; highCount++; }
                }

                this.bass = (bassSum / bassCount / 255) || 0;
                this.mid = (midSum / midCount / 255) || 0;
                this.high = (highSum / highCount / 255) || 0;

                // Energy
                let energySum = 0;
                for (let i = 0; i < this.bufferLength; i++) {
                    energySum += this.dataArray[i] * this.dataArray[i];
                }
                this.energy = Math.sqrt(energySum / this.bufferLength) / 255;

                // Beat/onset detection (OPTIMIZED - shorter history for less lag)
                this.energyHistory.push(this.energy);
                if (this.energyHistory.length > 4) this.energyHistory.shift(); // Reduced from 8 to 4 frames
                const avgEnergy = this.energyHistory.reduce((a, b) => a + b, 0) / this.energyHistory.length;

                const energyDiff = this.energy - avgEnergy;
                this.onset = energyDiff > 0 ? energyDiff * 5 : 0;

                // Adaptive beat threshold
                const threshold = 1.15 - (this.beatConfidence * 0.1); // Lower threshold when confident in BPM
                const beatDetected = this.energy > avgEnergy * threshold;
                this.beat = beatDetected ? energyDiff * 8 : 0;

                // üéµ BPM TRACKING: Record beat timestamps
                if (beatDetected && this.audioTime - this.lastBeatTime > 0.2) { // Debounce (200ms min)
                    this.beatHistory.push(this.audioTime);
                    if (this.beatHistory.length > 8) this.beatHistory.shift(); // Keep last 8 beats

                    this.lastBeatTime = this.audioTime;
                    this.detectBPM();

                    // üöÄ SCHEDULE FUTURE VISUAL EVENTS (Predictive sync!)
                    if (this.beatInterval > 0 && this.beatConfidence > 0.5) {
                        const nextBeat = this.audioTime + this.beatInterval;

                        // Pre-schedule particle explosion for next beat
                        this.scheduleEvent(nextBeat, (data) => {
                            // This fires EXACTLY on the beat in visual time!
                            agents.forEach(a => {
                                const angle = Math.random() * Math.PI * 2;
                                const force = data.intensity * 20;
                                a.vx += Math.cos(angle) * force;
                                a.vy += Math.sin(angle) * force;
                            });

                            // Spawn sparks on beat
                            for (let i = 0; i < Math.floor(data.intensity * 30); i++) {
                                sparks.push(new Spark(
                                    CX + (Math.random() - 0.5) * 200,
                                    CY + (Math.random() - 0.5) * 200
                                ));
                            }
                        }, { intensity: this.beat });
                    }
                }

                // Pitch detection (simplified autocorrelation)
                if (this.bufferLength > 0) {
                    let maxCorr = 0, bestLag = 0;
                    for (let lag = 20; lag < 200; lag++) {
                        let corr = 0;
                        for (let i = 0; i < this.bufferLength - lag; i++) {
                            corr += this.dataArray[i] * this.dataArray[i + lag];
                        }
                        if (corr > maxCorr) {
                            maxCorr = corr;
                            bestLag = lag;
                        }
                    }
                    this.pitch = this.audioContext.sampleRate / (bestLag * 2);
                    this.pitchConfidence = maxCorr / (this.bufferLength * 255 * 255);
                }

                // Spectral flux
                if (this.lastDataArray) {
                    let fluxSum = 0;
                    for (let i = 0; i < this.bufferLength; i++) {
                        const diff = this.dataArray[i] - this.lastDataArray[i];
                        if (diff > 0) fluxSum += diff * diff;
                    }
                    this.spectralFlux = Math.sqrt(fluxSum / this.bufferLength) / 255;
                } else {
                    this.lastDataArray = new Uint8Array(this.bufferLength);
                }
                this.lastDataArray.set(this.dataArray);

                // Effects
                this.chromatic = this.onset * 5;
                this.bloom = this.beat * 0.5;
                this.distortion = this.spectralFlux * 3;

                // Auto mode change on flux (now synced to beat phase)
                if (this.spectralFlux > 0.25 && Math.random() < 0.3) {
                    const modes = ['explosion', 'tornado', 'chaos', 'quantum', 'plasma'];
                    this.mode = modes[Math.floor(Math.random() * modes.length)];
                }

                // Intensity modulation (smoothed to avoid jank)
                if (this.beat > 0.15) {
                    this.intensity = Math.min(3, this.intensity + this.beat * 6);
                }

                // NOTE: Beat explosions now handled by scheduled events (see BPM tracking above)
                // This eliminates the ~67ms lag from the old immediate-trigger approach!
            }
        };

        // Noise
        function noise(x, y, seed = 0) {
            const n = Math.sin(x * 12.9898 + y * 78.233 + seed * 45.164) * 43758.5453123;
            return n - Math.floor(n);
        }

        // üåä PERLIN NOISE (for organic evolution)
        function perlin(x, octaves = 4) {
            let value = 0;
            let amplitude = 1;
            let frequency = 1;
            let maxValue = 0;

            for (let i = 0; i < octaves; i++) {
                const sampleX = x * frequency;
                const noise = Math.sin(sampleX) * 0.5 + Math.cos(sampleX * 1.3) * 0.5;
                value += noise * amplitude;
                maxValue += amplitude;
                amplitude *= 0.5;
                frequency *= 2;
            }

            return value / maxValue; // Normalize to -1 to 1
        }

        // AGENT
        class Agent {
            constructor(x, y, id) {
                this.x = x; this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.ax = 0; this.ay = 0;
                this.id = id;
                this.energy = 1;
                this.phase = Math.random() * Math.PI * 2;
                this.neighbors = [];
                this.age = 0;
                this.imageColorHint = null; // üé® Subtle color from image data
                this.colorOffset = Math.random() * 360; // üåà UNIQUE color per particle
                this.glitchAmount = 0; // üí• Glitch intensity
            }

            modeForces() {
                // üñºÔ∏è COMPLETE KILL during formation!
                const imageFormingStrength = U.imageSystem.imageReady ? U.imageSystem.morphProgress : 0;
                const formationPhase = imageFormingStrength > 0 && imageFormingStrength < 0.7;
                const modeSuppression = formationPhase ? 0 : (1 - imageFormingStrength * 0.2); // 100% kill!

                const dx = CX - this.x, dy = CY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                const I = U.intensity * modeSuppression;

                const bassMult = 1 + U.bass * 10;
                const midMult = 1 + U.mid * 8;
                const highMult = 1 + U.high * 6;

                switch(U.mode) {
                    case 'explosion':
                        this.ax -= dx * 0.004 * I * bassMult;
                        this.ay -= dy * 0.004 * I * bassMult;
                        break;
                    case 'implosion':
                        this.ax += dx * 0.006 * I * bassMult;
                        this.ay += dy * 0.006 * I * bassMult;
                        break;
                    case 'tornado':
                        const tangent = angle + Math.PI / 2;
                        this.ax += Math.cos(tangent) * 0.4 * I * midMult;
                        this.ay += Math.sin(tangent) * 0.4 * I * midMult;
                        break;
                    case 'chaos':
                        this.ax += (Math.random() - 0.5) * 0.8 * I * highMult;
                        this.ay += (Math.random() - 0.5) * 0.8 * I * highMult;
                        break;
                    case 'waves':
                        const waveFreq = 30 / (1 + U.mid * 3);
                        const wave = Math.sin(dist / waveFreq - U.t / 8) * I;
                        this.ax += Math.cos(angle) * wave * 0.3 * midMult;
                        this.ay += Math.sin(angle) * wave * 0.3 * midMult;
                        break;
                    case 'vortex':
                        for (let i = 0; i < 4; i++) {
                            const vAngle = (i / 4) * Math.PI * 2 + U.t / 40;
                            const vx = CX + Math.cos(vAngle) * 250;
                            const vy = CY + Math.sin(vAngle) * 250;
                            const vdx = vx - this.x, vdy = vy - this.y;
                            const vdist = Math.sqrt(vdx * vdx + vdy * vdy);
                            const va = Math.atan2(vdy, vdx) + Math.PI / 2;
                            this.ax += Math.cos(va) * 0.15 * I / (vdist / 100 + 1);
                            this.ay += Math.sin(va) * 0.15 * I / (vdist / 100 + 1);
                        }
                        break;
                    case 'quantum':
                        // Quantum tunneling
                        if (Math.random() < 0.005 * I) {
                            this.x = CX + (Math.random() - 0.5) * W * 0.6;
                            this.y = CY + (Math.random() - 0.5) * H * 0.6;
                        }
                        this.ax += (Math.random() - 0.5) * 0.3 * I;
                        this.ay += (Math.random() - 0.5) * 0.3 * I;
                        break;
                    case 'magnetic':
                        // Field lines
                        const fieldAngle = Math.atan2(this.y - CY, this.x - CX);
                        const fieldStrength = Math.sin(fieldAngle * 3 + U.t / 20) * 0.2 * I;
                        this.ax += Math.cos(fieldAngle) * fieldStrength;
                        this.ay += Math.sin(fieldAngle) * fieldStrength;
                        break;
                    case 'plasma':
                        const plasma = Math.sin(this.x / 50 + U.t / 10) +
                                      Math.sin(this.y / 50 + U.t / 10) +
                                      Math.sin((this.x + this.y) / 50 + U.t / 10);
                        this.ax += Math.cos(plasma) * 0.2 * I;
                        this.ay += Math.sin(plasma) * 0.2 * I;
                        break;
                }
            }

            attractorInfluence() {
                // üñºÔ∏è FULL kill during formation, restore after
                const imageFormingStrength = U.imageSystem.imageReady ? U.imageSystem.morphProgress : 0;
                const formationPhase = imageFormingStrength > 0 && imageFormingStrength < 0.4;
                const attractorSuppression = formationPhase ? 0.02 : (1 - imageFormingStrength * 0.3);

                U.attractors.forEach(a => {
                    const dx = a.x - this.x, dy = a.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < a.radius && dist > 0) {
                        let force = a.strength * (1 - dist / a.radius) * attractorSuppression;
                        if (a.type === 'strange') {
                            force *= Math.sin(U.t / 10 + a.phase);
                        }
                        this.ax += (dx / dist) * force * 0.15;
                        this.ay += (dy / dist) * force * 0.15;
                    }
                });
            }

            zoneInfluence() {
                U.zones.forEach(z => {
                    const dx = z.x - this.x, dy = z.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < z.radius) {
                        const force = z.strength * (1 - dist / z.radius);
                        if (z.hot) {
                            // Hot zone - repel
                            this.ax -= (dx / dist) * force * 0.1;
                            this.ay -= (dy / dist) * force * 0.1;
                        } else {
                            // Cold zone - attract
                            this.ax += (dx / dist) * force * 0.1;
                            this.ay += (dy / dist) * force * 0.1;
                        }
                    }
                });
            }

            // üåå IMAGE ATTRACTOR INFLUENCE: FREEZE to shape, then release
            imageInfluence() {
                const img = U.imageSystem;
                if (!img.imageReady || img.imageAttractors.length === 0) return;

                // üéØ EXTREME LOCK during formation!
                const formationPhase = img.morphProgress < 0.7; // First 70% = FROZEN
                const baseStrength = formationPhase ? 20.0 : 1.0; // MASSIVE force!
                const influenceStrength = Math.min(1, img.morphProgress * 3) * baseStrength;

                // Find nearest image attractor
                let nearest = null;
                let minDist = Infinity;

                img.imageAttractors.forEach(a => {
                    const dist = Math.hypot(a.x - this.x, a.y - this.y);
                    if (dist < minDist && dist < a.radius * 6) {
                        minDist = dist;
                        nearest = { ...a, dist };
                    }
                });

                if (nearest && nearest.dist > 0) {
                    const dx = nearest.x - this.x;
                    const dy = nearest.y - this.y;

                    const attractForce = nearest.strength * (1 - nearest.dist / (nearest.radius * 6)) * influenceStrength;

                    // During formation: MASSIVE PULL
                    const pullStrength = formationPhase ? 8.0 : 0.5; // 8x force!
                    this.ax += (dx / nearest.dist) * attractForce * pullStrength;
                    this.ay += (dy / nearest.dist) * attractForce * pullStrength;

                    // FREEZE particles during formation
                    if (formationPhase) {
                        this.vx *= 0.3; // Almost stop
                        this.vy *= 0.3;
                    } else if (nearest.dist < nearest.radius * 1.5) {
                        this.vx *= 0.93;
                        this.vy *= 0.93;
                    }

                    // üé® ABSORB COLOR from image
                    if (nearest.color) {
                        this.imageColorHint = nearest.color;
                    }
                }
            }

            update() {
                this.vx += this.ax;
                this.vy += this.ay;

                const friction = U.mode === 'chaos' ? 0.96 : 0.92;
                this.vx *= friction;
                this.vy *= friction;

                const maxSpeed = U.mode === 'explosion' ? 15 : (U.mode === 'quantum' ? 20 : 10);
                const speed = Math.sqrt(this.vx ** 2 + this.vy ** 2);
                if (speed > maxSpeed) {
                    this.vx = (this.vx / speed) * maxSpeed;
                    this.vy = (this.vy / speed) * maxSpeed;
                }

                this.x += this.vx;
                this.y += this.vy;

                // Wrap
                if (this.x < 0) this.x = W;
                if (this.x > W) this.x = 0;
                if (this.y < 0) this.y = H;
                if (this.y > H) this.y = 0;

                this.ax = 0; this.ay = 0;
                this.energy = 0.6 + Math.sin(U.t / 25 + this.id / 8) * 0.4;
                this.age++;
            }

            draw() {
                // üí• GLITCH POSITION on beats
                let drawX = this.x;
                let drawY = this.y;
                if (U.beat > 0.2 && Math.random() < U.beat) {
                    drawX += (Math.random() - 0.5) * U.beat * 20;
                    drawY += (Math.random() - 0.5) * U.beat * 20;
                }

                const dist = Math.hypot(this.x - CX, this.y - CY);

                // üß¨ USE COLOR GENOME as base + UNIQUE offset per particle
                const variation = dist / 2 + this.id * 5 + this.colorOffset;
                let color = U.getColorFromGenome(variation, this.energy);

                // üí• GLITCH: Random color corruption on beats!
                if (U.beat > 0.25 && Math.random() < 0.3) {
                    color.h = Math.random() * 360; // Full color chaos!
                    color.s = 80 + Math.random() * 20;
                }

                // üé® SUBTLE IMAGE COLOR INFLUENCE (if particle is near image features)
                if (this.imageColorHint && U.imageSystem.morphProgress > 0.3) {
                    const hint = this.imageColorHint;
                    // Convert RGB to HSL for subtle blend
                    const r = hint.r / 255, g = hint.g / 255, b = hint.b / 255;
                    const max = Math.max(r, g, b), min = Math.min(r, g, b);
                    const l = (max + min) / 2;

                    let h = 0, s = 0;
                    if (max !== min) {
                        const d = max - min;
                        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                        switch(max) {
                            case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                            case g: h = ((b - r) / d + 2) / 6; break;
                            case b: h = ((r - g) / d + 4) / 6; break;
                        }
                    }

                    // Subtle blend (20% image color, 80% genome)
                    const blendAmount = U.imageSystem.morphProgress * 0.2;
                    color.h = color.h * (1 - blendAmount) + (h * 360) * blendAmount;
                    color.s = color.s * (1 - blendAmount) + (s * 100) * blendAmount;
                }

                const size = 2 + this.energy * 2 + U.onset * 2;

                // Glow (use glitched position)
                const gradient = ctx.createRadialGradient(drawX, drawY, 0, drawX, drawY, size * 3);
                gradient.addColorStop(0, `hsla(${color.h}, ${color.s}%, ${color.l + 30}%, 0.95)`);
                gradient.addColorStop(0.4, `hsla(${color.h}, ${color.s}%, ${color.l + 10}%, 0.6)`);
                gradient.addColorStop(1, `hsla(${color.h}, ${Math.max(0, color.s - 20)}%, ${color.l - 10}%, 0)`);

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(drawX, drawY, size * 3, 0, Math.PI * 2);
                ctx.fill();

                // Core (use glitched position)
                ctx.fillStyle = `hsla(${color.h}, ${Math.min(100, color.s + 15)}%, ${Math.min(90, color.l + 35)}%, ${this.energy})`;
                ctx.beginPath();
                ctx.arc(drawX, drawY, size * 0.6, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // SPARK PARTICLE
        class Spark {
            constructor(x, y) {
                this.x = x; this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = 5 + Math.random() * 10;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1;
                this.size = 1 + Math.random() * 2;
                this.colorVariation = Math.random() * 60; // üß¨ Use for color genome
            }

            update() {
                this.vx *= 0.95;
                this.vy *= 0.95;
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.02;
                return this.life > 0;
            }

            draw() {
                // üß¨ USE COLOR GENOME
                const color = U.getColorFromGenome(this.colorVariation, this.life);
                ctx.fillStyle = `hsla(${color.h}, ${Math.min(100, color.s + 15)}%, ${Math.min(90, color.l + 20)}%, ${this.life})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Initialize
        const agents = [];
        const sparks = [];
        const AGENT_COUNT = 500; // Balanced for performance

        for (let i = 0; i < AGENT_COUNT; i++) {
            const angle = (i / AGENT_COUNT) * Math.PI * 2;
            const r = 100 + Math.random() * 200;
            agents.push(new Agent(
                CX + Math.cos(angle) * r,
                CY + Math.sin(angle) * r,
                i
            ));
        }

        // üåå INITIALIZE IMAGE SYSTEM
        U.initImageSystem();
        console.log('üß¨ Color Genome & Image Feed initialized');

        // MAIN LOOP
        function loop() {
            const now = performance.now();
            U.fps = Math.round(1000 / (now - U.lastTime));
            U.lastTime = now;

            U.t += 0.016;

            // üéØ DUAL-CLOCK SYNC: Update clocks FIRST (critical timing!)
            U.updateAudioClock();

            // üéµ PLL: Update beat phase prediction
            U.updateBeatPhase();

            U.updateEntropy();
            U.analyzeAudio();

            // ‚ö° PROCESS SCHEDULED EVENTS: Trigger pre-scheduled visual hits
            U.processScheduledEvents();

            // üß¨ EVOLVE COLOR GENOME: Organic color consciousness
            U.evolveColorGenome();

            // üåå UPDATE IMAGE SYSTEM: Process reality feed
            U.updateImageSystem();

            U.updateMode();
            U.updateAttractors();

            // Legacy hue (kept for beat indicator, but color genome is primary)
            let hueShift;
            if (U.audioActive && U.beatConfidence > 0.5) {
                hueShift = U.beatPhase * 30 + U.onset * 80;
            } else if (U.audioActive) {
                hueShift = U.spectralCentroid / 30 + U.beat * 150 + U.onset * 80;
            } else {
                hueShift = 0.8 + Math.random() * 3;
            }
            U.hue = (U.hue + hueShift) % 360;

            // Clear with trail
            const trailAlpha = U.beat > 0.3 ? 0.4 : 0.05;
            ctx.fillStyle = `rgba(0, 0, 0, ${trailAlpha})`;
            ctx.fillRect(0, 0, W, H);

            // üåå IMAGE IS INVISIBLE - particles dance & suggest shapes

            // Random events
            if (Math.random() < 0.004) {
                const shockX = Math.random() * W, shockY = Math.random() * H;
                agents.forEach(a => {
                    const dx = a.x - shockX, dy = a.y - shockY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 0 && dist < 500) {
                        const force = (500 - dist) / 50;
                        a.vx += (dx / dist) * force;
                        a.vy += (dy / dist) * force;
                    }
                });
            }

            // Mitosis
            if (U.mode === 'mitosis' && agents.length < 500 && Math.random() < 0.01) {
                const parent = agents[Math.floor(Math.random() * agents.length)];
                agents.push(new Agent(
                    parent.x + (Math.random() - 0.5) * 20,
                    parent.y + (Math.random() - 0.5) * 20,
                    agents.length
                ));
            }

            // Update agents
            agents.forEach(a => {
                a.modeForces();
                a.attractorInfluence();
                a.zoneInfluence();
                a.imageInfluence(); // üåå Image-based forces
                a.update();
            });

            // Draw connections
            agents.forEach((a, i) => {
                if (i % 3 !== 0) return;
                agents.forEach((b, j) => {
                    if (j <= i) return;
                    const dx = b.x - a.x, dy = b.y - a.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 100) {
                        const alpha = (1 - dist / 100) * 0.2;

                        // üß¨ USE COLOR GENOME for connections
                        const color = U.getColorFromGenome(dist, 0.6);
                        ctx.strokeStyle = `hsla(${color.h}, ${color.s}%, ${color.l}%, ${alpha})`;
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(a.x, a.y);
                        ctx.lineTo(b.x, b.y);
                        ctx.stroke();
                    }
                });
            });

            // Draw agents
            agents.forEach(a => a.draw());

            // üéµ VISUAL BEAT INDICATOR: Pulsing ring synced to beat phase
            if (U.beatPhase > 0 && U.beatConfidence > 0.5) {
                const ringPhase = U.beatPhase; // 0-1
                const ringSize = 30 + ringPhase * 80;
                const ringAlpha = (1 - ringPhase) * 0.6;

                ctx.strokeStyle = `hsla(${U.hue}, 100%, 60%, ${ringAlpha})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(CX, CY, ringSize, 0, Math.PI * 2);
                ctx.stroke();

                // Inner pulse on beat hit (phase near 0)
                if (ringPhase < 0.15) {
                    const hitAlpha = (0.15 - ringPhase) / 0.15;
                    ctx.fillStyle = `hsla(${U.hue}, 100%, 70%, ${hitAlpha * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(CX, CY, 40, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Update & draw sparks
            for (let i = sparks.length - 1; i >= 0; i--) {
                if (!sparks[i].update()) {
                    sparks.splice(i, 1);
                } else {
                    sparks[i].draw();
                }
            }

            // POST-PROCESSING EFFECTS
            fxCtx.clearRect(0, 0, W, H);

            // üí• CHROMATIC ABERRATION (GLITCH MODE!)
            if (U.chromatic > 0.1 || U.beat > 0.3) {
                const shift = Math.max(U.chromatic * 5, U.beat * 15); // BIGGER glitch on beats!
                fxCtx.globalAlpha = 0.4;
                fxCtx.globalCompositeOperation = 'screen';
                fxCtx.drawImage(baseCanvas, -shift, 0);
                fxCtx.drawImage(baseCanvas, shift, 0);

                // Extra glitch: vertical offset on big beats
                if (U.beat > 0.4) {
                    fxCtx.drawImage(baseCanvas, 0, -shift * 0.5);
                }

                fxCtx.globalAlpha = 1;
                fxCtx.globalCompositeOperation = 'source-over';
            }

            // Bloom
            if (U.bloom > 0.1) {
                fxCtx.globalAlpha = U.bloom * 0.5;
                fxCtx.filter = `blur(${U.bloom * 10}px)`;
                fxCtx.globalCompositeOperation = 'screen';
                fxCtx.drawImage(baseCanvas, 0, 0);
                fxCtx.filter = 'none';
                fxCtx.globalAlpha = 1;
                fxCtx.globalCompositeOperation = 'source-over';
            }

            // Update UI
            document.getElementById('fps').textContent = U.fps;
            document.getElementById('mode').textContent = U.mode.toUpperCase();
            document.getElementById('audio').textContent = U.audioActive ? 'ON' : 'OFF';
            document.getElementById('count').textContent = agents.length;
            document.getElementById('bass').textContent = U.bass.toFixed(2);
            document.getElementById('mid').textContent = U.mid.toFixed(2);
            document.getElementById('high').textContent = U.high.toFixed(2);
            document.getElementById('pitch').textContent = U.pitchConfidence > 0.01 ?
                U.pitch.toFixed(0) + 'Hz' : '-';

            // üéµ SYNC ENGINE UI
            document.getElementById('bpm').textContent = U.bpm > 0 ?
                U.bpm.toFixed(0) + (U.beatConfidence > 0.7 ? '‚úì' : '?') : '-';
            document.getElementById('phase').textContent = U.beatPhase > 0 ?
                (U.beatPhase * 100).toFixed(0) + '%' : '-';
            document.getElementById('latency').textContent = (U.latencyCompensation * 1000).toFixed(0);

            // üß¨ COLOR GENOME UI
            document.getElementById('colormode').textContent = U.colorGenome.harmonyMode.toUpperCase();

            // üñºÔ∏è IMAGE SYSTEM UI (beat-synced!)
            const imgCount = U.imageSystem.imageAttractors.length;
            const beatInfo = U.imageSystem.beatsPerImage === 0.5 ? '¬Ω' : U.imageSystem.beatsPerImage;
            document.getElementById('imagestate').textContent = U.imageSystem.imageReady ?
                `${imgCount}p ${U.imageSystem.beatCounter}/${beatInfo}b` : 'SCAN';

            requestAnimationFrame(loop);
        }

        loop();

        // AUDIO INIT
        document.getElementById('audioBtn').addEventListener('click', async () => {
            try {
                let stream;
                const choice = confirm('Capturer ONGLET avec audio?\n\nOUI = Onglet (YouTube/Spotify)\nNON = Microphone');

                if (choice && navigator.mediaDevices.getDisplayMedia) {
                    stream = await navigator.mediaDevices.getDisplayMedia({
                        video: true,
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 48000
                        }
                    });
                } else {
                    stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 48000
                        }
                    });
                }

                U.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                U.analyser = U.audioContext.createAnalyser();
                U.analyser.fftSize = 512;
                U.analyser.smoothingTimeConstant = 0;

                const source = U.audioContext.createMediaStreamSource(stream);
                source.connect(U.analyser);

                U.bufferLength = U.analyser.frequencyBinCount;
                U.dataArray = new Uint8Array(U.bufferLength);
                U.audioActive = true;

                document.getElementById('audioBtn').textContent = 'AUDIO ON ‚ö°';
                document.getElementById('audioBtn').style.background = 'rgba(0,255,0,0.5)';

            } catch (err) {
                console.error('Audio error:', err);
                alert('Erreur audio!\n\nAutorisez micro ou partagez onglet avec audio.');
            }
        });

        // Mouse
        baseCanvas.addEventListener('click', (e) => {
            const force = 8;
            agents.forEach(a => {
                const dx = e.clientX - a.x, dy = e.clientY - a.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 250 && dist > 0) {
                    a.vx += (dx / dist) * force;
                    a.vy += (dy / dist) * force;
                }
            });

            for (let i = 0; i < 50; i++) {
                sparks.push(new Spark(e.clientX, e.clientY));
            }
        });

        // ‚ö° LATENCY CALIBRATION: Arrow keys to adjust sync timing
        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp') {
                U.latencyCompensation += 0.005; // +5ms
                console.log(`Latency: ${(U.latencyCompensation * 1000).toFixed(0)}ms`);
            } else if (e.key === 'ArrowDown') {
                U.latencyCompensation = Math.max(0, U.latencyCompensation - 0.005); // -5ms
                console.log(`Latency: ${(U.latencyCompensation * 1000).toFixed(0)}ms`);
            } else if (e.key === 'r' || e.key === 'R') {
                // Reset to default
                U.latencyCompensation = 0.035;
                console.log('Latency reset to 35ms');
            } else if (e.key === 'i' || e.key === 'I') {
                // üåå Force new image
                U.fetchRandomImage();
                console.log('üñºÔ∏è Loading new image...');
            } else if (e.key === 'm' || e.key === 'M') {
                // üß¨ Force color mutation
                const modes = ['mono', 'duo', 'triad', 'multi', 'bw'];
                U.colorGenome.harmonyMode = modes[Math.floor(Math.random() * modes.length)];
                console.log(`üß¨ Color mode: ${U.colorGenome.harmonyMode}`);
            }
        });
    </script>
</body>
</html>